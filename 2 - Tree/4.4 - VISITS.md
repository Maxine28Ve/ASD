# How to visit a tree?
Visits to Binomial Trees can be made in many ways. 
They allow us to access the information contained in the trees we are using.

---

## Generic Visit
This general type of visit helps understand how we can obtain different types of visits, 
by changing of data structure
1. Inserts the root inside a set S
2. While S != EMPTY_SET
   1. Extract a node u from S 
   2. Visit the node u
   3. Add to S the children of u

```python
generic_visit(Node r)
    S = {r} # Inserts the root inside a set S
    while (S != EMPTY_SET):
        # Extract a node u from S
        # Visit the node u
        S = Union(S, children(u));
```
**Final Time Complexity**: T(n) = <mark>O(n)</mark>
* Suppose that insertion and deletion occur in O(1), 
since a node will be inserted and extracted once from S. In fact, _using a tree
we cannot go from a node x to its parent node_.

Space Complexity: S(n) = O(n)
* The while iteration will be at most O(n), since each node appear at most once in S.
---

## Depth First Search - Pre Order
Idea: Root > Left Child > Right Child

What happens here is that we start from the root and keep going deeper on the **left child side** until we manage to
explore the whole left subtree. Then, we pass to the right subtree.

We use a <mark>Stack</mark> 

### Iterative
1. Create an empty stack S
2. Push a node in the stack 
3. While the stack is not empty
   1. Pop the first node *u* from the stack
   2. Check if u is empty
   3. Push first right child
   4. Push left child (as last, so we can go in depth)

```python
DFS_visit_iter(Node r)
    Stack s = create_stack();
    push(S,r);
    while(not stack_empty(S))
        Node u = pop(s);
        if(u!= NULL)
            # Visit u
            push(s, u.right);
            push(s, u.left);
```
**Final Time Complexity**: T(n) = <mark>O(n)</mark>
* Push, Pop can be implemented in costant time

### Recursive
1. Start from a node
2. If tree is not empty
   1. 

```python
DFS_visit_rec(Node r)
    if(r != NULL):
        #Visit r
        DFS_visit_rec(r.left);
        DFS_visit_rec(r.right);
```
**Final Time Complexity**: T(n) = <mark>Î˜(n)</mark>

ATTENTION: **Base Case** on Trees for Recursive Algorithms: Empty Tree.

---

## Symmetric Visit - In Order
Idea: Left Child > Root > Right Child

---

---

## Visit - Post-Order
Idea: Left Child > Right Child > Root

---

## Bread First Search (BFS)

---

## Level-Order Visit
1. Visit Root
2. Enqueue Left Child;
3. Enqueue Right Child;
4. Visit on Dequeue;
5. Back to 2. with the next element of the queue which is popped out and deleted


