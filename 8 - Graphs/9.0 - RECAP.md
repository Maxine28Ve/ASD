# Graph Recap

| **Algorithm**    | **Correctness Demonstration**                                                                                               | **Complexity**        | **Implementation**                     |
|------------------|-----------------------------------------------------------------------------------------------------------------------------|-----------------------|----------------------------------------|
| _Kruskal_        | FT of MST & Corollary 23.2   Kruskal manages the cut through extraction process and extracts only light edges for that cut. | O(m*log(m))           | Disjoint Forest                        |
| _Prim_           | FT of MST & Corollary 23.2  At each iteration, the selection of a safe edge always results in a  MST                        | O(m*log(n))           | PQ(Binary Heap)                        |
| _Dijkstra_       | Theorem of Dijkstra                                                                                                         | O(n^2), O(m * log(n)) | Array (Dense), PQ Binary Heap (Sparse) |
| _Bellman-Ford_   | BF's Correctness Theorem (Part 1 and 2)                                                                                     | Θ(nm)                 | Array or PQ                            |
| _Floyd-Warshall_ | FW's Correctness Theorem                                                                                                    | Θ(n^3)                | Matrix-like structure                  |

##Kruskal
```python
MST_KRUSKAL(Graph G, Function w)
    A <- {}
    for (Vertex v in G.V):
        make_set(v);    #initialize the sets
    sort(G.E)       #sorts smallest to largest
    for (each Edge (u,v) in G.E):   #in order
        if(find_set(u) != find_set(v)): #if it does not create a cycle
            union(u,v);
            A <- A U {(u,v)};
    return A;
```

### Goal
To find an MST of a graph G

### Restrictions
* G(V,E,w) must be connected, undirected and an edge-weighted graph, with a real value function w

### Data Structures
* Disjoint Set ADT

### Correctness Demonstration
* Part 1: Consequence of [F.T. of MST](https://github.com/PayThePizzo/DataStrutucures-Algorithms/blob/main/8%20-%20Graphs/6.1%20-%20MST.md#fundamental-theorem-of-mst)
* Part 2: Consequence of [Corollary 23.2](https://github.com/PayThePizzo/DataStrutucures-Algorithms/blob/main/8%20-%20Graphs/6.3%20-%20KRUSKAL.md#2---correctness-demonstration) for Kruskal.

### Complexity
T(n) = <mark>**O(m * log(m))**</mark>
1. First cycle = O(n)
2. Sorting = O(m*log(m))
3. Second cycle and operations = O(m * log(m))

---

##Prim
```python
MST_PRIM(Graph G, Function w, Vertex r)
    Q = V.G
    for(u in G.V):                  #initialization
        key[u] = inf();
        pi[u] = NULL;
    key[r] = 0;
    while (Q != ∅):                 #extraction
        u <- extract_min(Q)         
        for (v in adj[u]):     #update data structures
            if (v in Q and w(u,v)<key[v]):
                pi[v] = u
                key[v] = w(u,v)
    return A = {(u, pi[u]) in E | u in V\{r}} #return
```

### Goal
To find an MST of a graph G

### Restrictions
* G(V,E,w) must be connected, undirected and an edge-weighted graph, with a real value function w

### Data Structures
* Priority Queue

### Correctness Demonstration
* Part 1: Consequence of [F.T. of MST](https://github.com/PayThePizzo/DataStrutucures-Algorithms/blob/main/8%20-%20Graphs/6.1%20-%20MST.md#fundamental-theorem-of-mst)
* Part 2: Consequence of [Corollary 23.2](https://github.com/PayThePizzo/DataStrutucures-Algorithms/blob/main/8%20-%20Graphs/6.4%20-%20PRIM.md#2---correctness-demonstration) for Prim.

### Complexity
T(n) = <mark>**O(m * log(n))**</mark>
1. Initialization: T(n) = Θ(n)
2. Extraction: T(n) = O(m* log(n)) = O(n) + O(n * log(n)) + (m * log(n))
   1. While: T(n) = O(n)
   2. Extract_min(): T(n)= O(log(n))
   3. For: T(n) = Θ(m) = Θ(2m) = sum(deg(u(i)), i= 1 to n)
      1. Not constant, in function adj[u]
   4. key[v] = w(u,v): T(n) = O(log(n))
      1. Re-balancing of the queue
3. Return: constant

---

##Dijkstra
```python
Dijkstra(Graph G, Weight w, Vertex s)
    INIT_SS(G, s)
    Q = V[G]
    S = ∅
    while(Q != ∅):
        u = EXTRACT_MIN(Q); 
        S = S ∪ {u};
        for(Vertex v in Adj[u]): #Relax every leaving vertex.
            RELAX(u, v, w);
    return (d, Gπ);
```

### Goal

### Restrictions & Data Structures

### Correctness Demonstration

### Complexity


---

##BF
```python
BELLMAN_FORD(Graph G, Weight w, Vertex s)
    for(i=1 to |G.V|-1):
        for((u,v) in G.E):
            RELAX(u,v, w(u,v));
    for((u,v) in G.E):
        if(d[v]>d[u]+w(u,v)):
            return (False, d, π);
    return (True, d, π); #No negative cycles
```

### Goal

### Restrictions & Data Structures

### Correctness Demonstration

### Complexity


---

##FW
```python
FLOYD_WARSHALL(W)
    n = count(W.rows);
    D^0 = W;
    for(k=1 to n): #Computes the sequence of D^k
        for(i=1 to n):
            for(j=1 to n):
                d^k(ij) = min{d^k-1(ik)+ d^k-1(kj), d^k-1(ij)};
    return D^n;
```

### Goal

### Restrictions & Data Structures

### Correctness Demonstration

### Complexity


---

