# Graph Recap

| **Algorithm**    | **Correctness Demonstration**                                                                                               | **Complexity**        | **Implementation**                     |
|------------------|-----------------------------------------------------------------------------------------------------------------------------|-----------------------|----------------------------------------|
| _Kruskal_        | FT of MST & Corollary 23.2   Kruskal manages the cut through extraction process and extracts only light edges for that cut. | O(m*log(m))           | Disjoint Forest                        |
| _Prim_           | FT of MST & Corollary 23.2  At each iteration, the selection of a safe edge always results in a  MST                        | O(m*log(n))           | PQ(Binary Heap)                        |
| _Dijkstra_       | Theorem of Dijkstra                                                                                                         | O(n^2), O(m * log(n)) | Array (Dense), PQ Binary Heap (Sparse) |
| _Bellman-Ford_   | BF's Correctness Theorem (Part 1 and 2)                                                                                     | Θ(nm)                 | Array or PQ                            |
| _Floyd-Warshall_ | FW's Correctness Theorem                                                                                                    | Θ(n^3)                | Matrix-like structure                  |

##Kruskal
```python
MST_KRUSKAL(Graph G, Function w)
    A <- {}
    for (Vertex v in G.V):
        make_set(v);    #initialize the sets
    sort(G.E)       #sorts smallest to largest
    for (each Edge (u,v) in G.E):   #in order
        if(find_set(u) != find_set(v)): #if it does not create a cycle
            union(u,v);
            A <- A U {(u,v)};
    return A;
```


##Prim
```python
MST_PRIM(Graph G, Function w, Vertex r)
    Q = V.G
    for(u in G.V):                  #initialization
        key[u] = inf();
        pi[u] = NULL;
    key[r] = 0;
    while (Q != ∅):                 #extraction
        u <- extract_min(Q)         
        for (v in adj[u]):     #update data structures
            if (v in Q and w(u,v)<key[v]):
                pi[v] = u
                key[v] = w(u,v)
    return A = {(u, pi[u]) in E | u in V\{r}} #return
```


##Dijkstra
```python
Dijkstra(Graph G, Weight w, Vertex s)
    INIT_SS(G, s)
    Q = V[G]
    S = ∅
    while(Q != ∅):
        u = EXTRACT_MIN(Q); 
        S = S ∪ {u};
        for(Vertex v in Adj[u]): #Relax every leaving vertex.
            RELAX(u, v, w);
    return (d, Gπ);
```


##BF
```python
BELLMAN_FORD(Graph G, Weight w, Vertex s)
    for(i=1 to |G.V|-1):
        for((u,v) in G.E):
            RELAX(u,v, w(u,v));
    for((u,v) in G.E):
        if(d[v]>d[u]+w(u,v)):
            return (False, d, π);
    return (True, d, π); #No negative cycles
```


##FW
```python
FLOYD_WARSHALL(W)
    n = count(W.rows);
    D^0 = W;
    for(k=1 to n): #Computes the sequence of D^k
        for(i=1 to n):
            for(j=1 to n):
                d^k(ij) = min{d^k-1(ik)+ d^k-1(kj), d^k-1(ij)};
    return D^n;
```