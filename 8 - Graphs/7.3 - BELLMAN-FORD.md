# Bellman-Ford
The Bellman-Ford algorithm solves the single-source shortest-paths problem on a weighted,
directed graph G=(V,E) in the general case in which edge weights may be negative.
The algorithm **returns a boolean value** indicating whether there is a negative-weight 
cycle that is reachable from the source. 
* If there is such a cycle, the algorithm indicates that no solution exists. 
* If there is no such cycle, the algorithm produces the shortest paths and their weights.

## Data Structures
No relevant data structure to analyze, we can use either arrays or queues. This choice would not impact the outcome of the 
complexity.

## Algorithm
It is composed of two parts:
1) The first part is the main algorithm
   1) It performs n-1 brute force iterations, where it executes RELAX() on all edges of the graph. Basically,
   it consists of <mark>n-1 relaxations on all edges.</mark>
      1) Dijkstra only iterates through all edges once (m iterations).
2) The second part aims at locating the existence of negative cycles

```python
BELLMAN_FORD(Graph G, Weight w, Vertex s)
    for(i=1 to |G.V|-1):
        for((u,v) in G.E):
            RELAX(u,v, w(u,v));
    for((u,v) in G.E):
        if(d[v]>d[u]+w(u,v)):
            return (False, d, π);
    return (True, d, π); #No negative cycles
```
**Final Time Complexity**: T(n) = <mark>**Θ(nm)**</mark> = Θ(n + (n-1)m + m)

### 1 - Complexity Demonstration
1) INIT_SS(): T(n) = Θ(n)
2) First Part: T(n) = O(n-1 * m)
   1) For: T(n) = O(n-1)
   2) For each: T(n) = O(m)
      1) RELAX(): T(n) = O(1)
3) Second Part: T(n) = O(m)
   1) For each: T(n) = O(m)
      1) Check: T(n) = O(1)

#### BF vs Dijkstra

![bfdj comp](https://github.com/PayThePizzo/DataStrutucures-Algorithms/blob/main/Resources/bfdjcomp.png?raw=TRUE)

BF is more efficient when it comes to using data structures (maintaining a PQ is more expensive).
Even though Dijkstra is a better fit almost always, we have can use BF more generally.


### 2 - Correctness Demonstration: BF's correctness theorem.
The theorem is divided into two parts. We distinguish the cases where:
1) The graph excludes negative cycles
2) The graph includes negative cycles

### Graph - Neg. Cycles excluded
Let's execute B.F. on a graph G=(V,E, `w:E->R`) with s as source vertex s∈V. If G excludes negative cycles
reachable from s, at the end of the algorithm the following statements stay true:
1) d[u] = δ(s,u) ∀u∈V 
2) Gπ is a shortest-path tree
3) The algorithm returns `True`

#### Demonstration - cases 1, 3
Case 1: If we take a generic vertex u∈V, we have three cases
1) δ(s,u)=+inf(), trivial
2) δ(s,u) is a real number
   1) ∃p(s,u), there exists, at least, one path between s and u, so there must exist a shortest-path
   (we do not have negative cycles) that is simple.
      1) p is a **simple** shortest-path between s and u
      2) <mark>p has max n-1 edges</mark>
3) ~~δ(s,u)=-inf()~~. Impossible, there are no negative cycles

Let's say

### Graph - Neg. Cycles included
If in G there are negative cycles reachable from s, at the end of the algorithm the following 
statements stay true:
1) The algorithm returns `False`



---

### Example

---

### CPU Improvement